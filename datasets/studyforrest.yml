################################################################################
# This file contains the configuration for the cortex-annotate toolkit. By
# editing this file, one can configure cortex-annotate to work with various
# datasets and to enable annotation of specific contours, points, and
# boundaries.

display:
  figsize: [4, 4]
  dpi: 128
  plot_options:
    color: [0.97, 0.97, 0.97]
    markersize: 0
    linewidth: 2
    linestyle: "solid"
  fg_options:
    color: [0.55, 0.55, 0.9]
    markersize: 2

init: |
  # Load libraries that will be used throughout the configuration file.
  import re
  import glob
  import numpy as np
  import os.path as op
  import neuropythy as ny
  from struct import unpack
  
  # Define directories
  dataset  = "studyforrest"
  data_dir = op.join("/home", "jovyan", "datasets", dataset)

  # define flatmap kwargs
  FLATMAP_KWARGS = {
    "mask"      : ( "parcellation", 43 ), 
    "map_right" : "right",
    "radius"    : np.pi / 2
  }

  # load fsaverage as a subject object
  fsa = ny.freesurfer_subject("fsaverage")

  # prepare fsaverage flatmap
  fsa_flatmaps = {} # initialize
  fsa_flatmaps["lh"] = fsa.hemis["lh"].mask_flatmap(**FLATMAP_KWARGS)
  fsa_flatmaps["rh"] = fsa.hemis["rh"].mask_flatmap(**FLATMAP_KWARGS)

targets:
  # The "Participant" is a choice for the user. It will appear as a dropdown 
  # menu with these two options in the annotation tool.
  Participant:
    - sub-01
    - sub-02
    - sub-03
    - sub-04
    - sub-05
    - sub-06
    - sub-09
    - sub-10
    - sub-14
    - sub-15
    - sub-16
    - sub-17
    - sub-18
    - sub-19
    - sub-20

  # The "Hemisphere" is a choice for the user; as a list of two options, it will
  # appear as a dropdown menu with these two options in the annotation tool.
  Hemisphere:
    - Left Hemisphere
    - Right Hemisphere

  # create subject flatmap.
  flatmap: |
    # get dropdown selections from above choices.
    participant = target["Participant"] # string
    hemi        = target["Hemisphere"]  # string

    # format dropdown items
    fs_hemi = f"{hemi[0].lower()}h"

    # define participant directory
    participant_dir = op.join(data_dir, participant)

    # find all participant property files
    prop_files = glob.glob(op.join(participant_dir, f"{fs_hemi}.2d.*"))

    # read in all subject properties
    props = {} # initialize
    for fname in prop_files: # for each property file
      prop_name = fname.split(".")[-1]
      with open(fname, "rb") as f:
        values = f.read() # read property file, float16
        values = unpack("e" * (len(values) // 2), values)
      props[prop_name] = values

    # copy fsaverage flatmap 
    participant_flatmap = fsa_flatmaps[fs_hemi].copy()

    # attatch and return properties to fsaverage flatmap
    return participant_flatmap.with_prop(props)

annotations:
  # V1 contours:
  V1 Foveal Point:
    type: point
    grid:
      - ["angle", "eccen"]
      - ["curvature", "vexpl"]
  V1 UVM (ventral):
    fixed_head: V1 Foveal Point
    grid:
      - ["angle", "eccen"]
      - ["curvature", "vexpl"]
  V1 LVM (dorsal):
    fixed_head: V1 Foveal Point
    grid:
      - ["angle", "eccen"]
      - ["curvature", "vexpl"]
  V1 Periphery:
    fixed_head:
      requires: V1 UVM (ventral)
      calculate: |
        return annotations["V1 UVM (ventral)"][-1,:]
    fixed_tail:
      requires: V1 LVM (dorsal)
      calculate: |
        return annotations["V1 LVM (dorsal)"][-1,:]
    grid:
      - ["angle", "eccen"]
      - ["curvature", "vexpl"]
  # V2 contours:
  V2 Foveal Point:
    type: point
    grid:
      - ["angle", "eccen"]
      - ["curvature", "vexpl"]
  V2 UVM (ventral):
    fixed_head: V2 Foveal Point
    grid:
      - ["angle", "eccen"]
      - ["curvature", "vexpl"]
  V2 LVM (dorsal):
    fixed_head: V2 Foveal Point
    grid:
      - ["angle", "eccen"]
      - ["curvature", "vexpl"]
  V2 Ventral Periphery:
    fixed_head:
      requires: V2 UVM (ventral)
      calculate: |
        return annotations["V2 UVM (ventral)"][-1,:]
    fixed_tail:
      requires: V1 UVM (ventral)
      calculate: |
        return annotations["V1 UVM (ventral)"][-1,:]
    grid:
      - ["angle", "eccen"]
      - ["curvature", "vexpl"]
  V2 Dorsal Periphery:
    fixed_head:
      requires: V2 LVM (dorsal)
      calculate: |
        return annotations["V2 LVM (dorsal)"][-1,:]
    fixed_tail:
      requires: V1 LVM (dorsal)
      calculate: |
        return annotations["V1 LVM (dorsal)"][-1,:]
    grid:
      - ["angle", "eccen"]
      - ["curvature", "vexpl"]
  # V3 contours:
  V3 Foveal Point:
    type: point
    grid:
      - ["angle", "eccen"]
      - ["curvature", "vexpl"]
  V3 UVM (ventral):
    fixed_head: V3 Foveal Point
    grid:
      - ["angle", "eccen"]
      - ["curvature", "vexpl"]
  V3 LVM (dorsal):
    fixed_head: V3 Foveal Point
    grid:
      - ["angle", "eccen"]
      - ["curvature", "vexpl"]
  V3 Ventral Periphery:
    fixed_head:
      requires: V3 UVM (ventral)
      calculate: |
        return annotations["V3 UVM (ventral)"][-1,:]
    fixed_tail:
      requires: V2 UVM (ventral)
      calculate: |
        return annotations["V2 UVM (ventral)"][-1,:]
    grid:
      - ["angle", "eccen"]
      - ["curvature", "vexpl"]
  V3 Dorsal Periphery:
    fixed_head:
      requires: V3 LVM (dorsal)
      calculate: |
        return annotations["V3 LVM (dorsal)"][-1,:]
    fixed_tail:
      requires: V2 LVM (dorsal)
      calculate: |
        return annotations["V2 LVM (dorsal)"][-1,:]
    grid:
      - ["angle", "eccen"]
      - ["curvature", "vexpl"]
  # hV4 contour:
  hV4 Outer:
    type: contour
    fixed_head: V3 Foveal Point
    grid:
      - ["angle", "eccen"]
      - ["curvature", "vexpl"]
  # VO contour:
  VO Outer:
    type: contour
    fixed_head:
      requires: V3 UVM (ventral)
      calculate: |
        return annotations["V3 UVM (ventral)"][-1,:]
    grid:
      - ["angle", "eccen"]
      - ["curvature", "vexpl"]
  # hV4|VO boundary:
  hV4|VO Boundary:
    type: contour
    grid:
      - ["angle", "eccen"]
      - ["curvature", "vexpl"]
  # VO1|2 boundary:
  VO1|2 Boundary:
    type: contour
    grid:
      - ["angle", "eccen"]
      - ["curvature", "vexpl"]
  # V3a|b contours:
  V3a|b Outer:
    type: contour
    fixed_head:
      requires: V3 LVM (dorsal)
      calculate: |
        return annotations["V3 LVM (dorsal)"][-1,:]
    grid:
      - ["angle", "eccen"]
      - ["curvature", "vexpl"]
  V3a|b Inner Boundary:
    type: contour
    grid:
      - ["angle", "eccen"]
      - ["curvature", "vexpl"]
  # IPS Outer:
  IPS Outer:
    type: contour
    grid:
      - ["angle", "eccen"]
      - ["curvature", "vexpl"]
  VO1|2 Outer: 
    type: contour
    fixed_head: V3 Foveal Point
    grid:
      - ["angle", "eccen"]
      - ["curvature", "vexpl"]
 

figures:
  term: |
    # figure aesthetics and limits
    xy = target["flatmap"].coordinates
    (xmin, ymin) = np.min(xy, axis = 1)
    (xmax, ymax) = np.max(xy, axis = 1)
    axes.set_xlim((xmin, xmax))
    axes.set_ylim((ymin, ymax))
  angle: |
    # prepare hemisphere information
    hemi    = target["Hemisphere"]  # string
    fs_hemi = f"{hemi[0].lower()}h"

    ny.cortex_plot(target["flatmap"], 
      color = { f"polar_angle_{fs_hemi}": target["flatmap"].properties["angle"] }, 
      axes = axes)
  eccen: |
    ny.cortex_plot(target["flatmap"], 
      color = { "eccentricity": target["flatmap"].properties["eccen"] }, 
      axes = axes)
  vexpl: |
    ny.cortex_plot(target["flatmap"], color = "vexpl", cmap = "hot", 
      vmin = 0, vmax = 100, axes = axes)
  curvature: |
    ny.cortex_plot(target["flatmap"], axes = axes)

review: |
  #from annotate import watershed_contours
  #im = watershed_contours(annotations.values(), max_depth=1)
  #axes.imshow(im, cmap="hsv", vmin=0, vmax=1.5*np.max(im))
  import numpy as np
  # V1:
  v1uvm = annotations["V1 UVM (ventral)"]
  v1lvm = annotations["V1 LVM (dorsal)"]
  v1per = annotations["V1 Periphery"]
  v1pol = np.vstack([v1uvm, v1per, np.flipud(v1lvm)])
  # V2:
  v2uvm = annotations["V2 UVM (ventral)"]
  v2lvm = annotations["V2 LVM (dorsal)"]
  v2pev = annotations["V2 Ventral Periphery"]
  v2ped = annotations["V2 Dorsal Periphery"]
  v2pol = np.vstack(
      [v2uvm, v2pev, np.flipud(v1uvm), v1lvm, np.flipud(v2ped), np.flipud(v2lvm)])
  # V3:
  v3uvm = annotations["V3 UVM (ventral)"]
  v3lvm = annotations["V3 LVM (dorsal)"]
  v3pev = annotations["V3 Ventral Periphery"]
  v3ped = annotations["V3 Dorsal Periphery"]
  v3pol = np.vstack(
      [v3uvm, v3pev, np.flipud(v2uvm), v2lvm, np.flipud(v3ped), np.flipud(v3lvm)])
  # Turn these into traces:
  fmap = target["flatmap"]
  v1_trace = ny.path_trace(fmap, v1pol.T, closed=True)
  v2_trace = ny.path_trace(fmap, v2pol.T, closed=True)
  v3_trace = ny.path_trace(fmap, v3pol.T, closed=True)
  # Convert the path traces into paths then into labels:
  cortex = target["cortex"]
  v1_path = v1_trace.to_path(cortex)
  v2_path = v2_trace.to_path(cortex)
  v3_path = v3_trace.to_path(cortex)
  v1 = v1_path.label > 0.5
  v2 = v2_path.label > 0.5
  v3 = v3_path.label > 0.5
  if np.sum(v1) > np.sum(~v1):
    v1 = ~v1
  if np.sum(v2) > np.sum(~v2):
    v2 = ~v2
  if np.sum(v3) > np.sum(~v3):
    v3 = ~v3
  labels = np.zeros(cortex.vertex_count, dtype=int)
  labels[v1] = 1
  labels[v2] = 2
  labels[v3] = 3
  fmap_labels = labels[fmap.labels]
  # If the user saves the contours, we want to save these labels.
  save_hooks["v123-labels.mgz"] = lambda filename: ny.save(filename, labels)
  # Plot the results:
  ny.cortex_plot(
    fmap,
    color = fmap_labels,
    cmap  = "rainbow",
    mask  = (fmap_labels > 0),
    axes  = axes,
    alpha = 0.5
  )
  axes.axis("equal")
  axes.axis("off")
