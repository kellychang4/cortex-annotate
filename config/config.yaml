################################################################################
# This file contains the configuration for the cortex-annotate toolkit. By
# editing this file, one can configure cortex-annotate to work with various
# datasets and to enable annotation of specific contours, points, and
# boundaries.

display:
  figsize: [4, 4]
  dpi: 128
  active_style:
    color: [0.97, 0.97, 0.97]
    markersize: 4
  default_style:
    color: [0.55, 0.55, 0.9]
    markersize: 0
    linewidth: 2
    linestyle: "solid"
    

init: |
  # Load libraries that will be used throughout the configuration file.
  import re
  import glob
  import numpy as np
  import os.path as op
  import neuropythy as ny
  from struct import unpack
  from matplotlib.colors import LinearSegmentedColormap

  # define dataset directory (inside Docker container)
  datasets_dir = op.join("/home", "jovyan", "datasets") 
  
  # define flatmap kwargs
  FLATMAP_KWARGS = {
    "mask"      : ( "parcellation", 43 ), 
    "map_right" : "right",
    "radius"    : np.pi / 2
  }

  # load fsaverage as a subject object
  fsa = ny.freesurfer_subject("fsaverage")

  # prepare fsaverage flatmap
  fsa_flatmaps = {} # initialize
  fsa_flatmaps["lh"] = fsa.hemis["lh"].mask_flatmap(**FLATMAP_KWARGS)
  fsa_flatmaps["rh"] = fsa.hemis["rh"].mask_flatmap(**FLATMAP_KWARGS)

  # define a custom colormap for isoeccentricity figures
  edge_cmap = LinearSegmentedColormap.from_list(
    name = "edge", 
    colors = [
      (0, (0, 1, 1)),    # negative values begin at cyan
      (0.49, (0, 0, 0)), # black edge, just before the threshold value
      (0.50, (1, 1, 0)), # yellow edge, at the threshold value
      (0.51, (1, 1, 1)), # white edge, just after the threshold value
      (1, (1, 0, 0))     # positive values go towards red
    ]
  )

targets:
  # The "Dataset" is a choice for the user; as a list of one option.
  Dataset:
    - CHN-Retinotopy
    - HCP-Retinotopy
    - NOD
    - NSD
    - NYU-Retinotopy
    - StudyForrest

  # The "Participant" is a choice for the user. It will depend on the dataset
  # selection, so we define it as a function returning the list of participants.
  Participant: 
    depends_on: Dataset
    calculate: |
      # get dropdown selection from above choices.
      dataset = target["Dataset"].lower() # string

      # define dataset directory
      dataset_dir = op.join(datasets_dir, dataset)

      # find all participant directories in dataset directory
      participant_dirs = glob.glob(op.join(dataset_dir, "*"))

      # extract participant names from participant directories
      participants = [op.basename(d) for d in participant_dirs]

      # return list of participants for dropdown menu
      return participants

  # The "Hemisphere" is a choice for the user; as a list of two options.
  Hemisphere:
    - Left Hemisphere
    - Right Hemisphere

  # create subject flatmap.
  flatmap: |
    # get dropdown selections from above choices.
    dataset     = target["Dataset"].lower() # string
    participant = target["Participant"]     # string
    hemisphere  = target["Hemisphere"]      # string

    # format dropdown items
    fs_hemi = f"{hemisphere[0].lower()}h"

    # define participant directory
    participant_dir = op.join(datasets_dir, dataset, participant)

    # find all participant property files
    prop_files = glob.glob(op.join(participant_dir, f"{fs_hemi}.2d.*"))

    # read in all subject properties
    props = {} # initialize
    for fname in prop_files: # for each property file
      prop_name = fname.split(".")[-1]
      with open(fname, "rb") as f:
        values = f.read() # read property file, float16
        values = unpack("e" * (len(values) // 2), values)
      props[prop_name] = values

    # copy fsaverage flatmap 
    participant_flatmap = fsa_flatmaps[fs_hemi].copy()

    # attach and return participant flatmap with properties
    return participant_flatmap.with_prop(props)


annotations:
  # V1 contours:
  V1 Foveal Point:
    type: point
    figure_grid:
      - ["angle", "eccen"]
      - ["curvature", "vexpl"]
  V1 UVM (ventral):
    fixed_head: V1 Foveal Point
    figure_grid:
      - ["angle", "eccen"]
      - ["curvature", "vexpl"]
  V1 LVM (dorsal):
    fixed_head: V1 Foveal Point
    figure_grid:
      - ["angle", "eccen"]
      - ["curvature", "vexpl"]
  V1 Periphery:
    fixed_head: V1 UVM (ventral)
    fixed_tail: V1 LVM (dorsal)
    figure_grid:
      - ["angle", "eccen"]
      - ["curvature", "vexpl"]
  # V2 contours:
  V2 Foveal Point:
    type: point
    figure_grid:
      - ["angle", "eccen"]
      - ["curvature", "vexpl"]
  V2 UVM (ventral):
    fixed_head: V2 Foveal Point
    figure_grid:
      - ["angle", "eccen"]
      - ["curvature", "vexpl"]
  V2 LVM (dorsal):
    fixed_head: V2 Foveal Point
    figure_grid:
      - ["angle", "eccen"]
      - ["curvature", "vexpl"]
  V2 Ventral Periphery:
    fixed_head: V2 UVM (ventral)
    fixed_tail: V1 UVM (ventral)
    figure_grid:
      - ["angle", "eccen"]
      - ["curvature", "vexpl"]
  V2 Dorsal Periphery:
    fixed_head: V2 LVM (dorsal)
    fixed_tail: V1 LVM (dorsal)
    figure_grid:
      - ["angle", "eccen"]
      - ["curvature", "vexpl"]
  # V3 contours:
  V3 Foveal Point:
    type: point
    figure_grid:
      - ["angle", "eccen"]
      - ["curvature", "vexpl"]
  V3 UVM (ventral):
    fixed_head: V3 Foveal Point
    figure_grid:
      - ["angle", "eccen"]
      - ["curvature", "vexpl"]
  V3 LVM (dorsal):
    fixed_head: V3 Foveal Point
    figure_grid:
      - ["angle", "eccen"]
      - ["curvature", "vexpl"]
  V3 Ventral Periphery:
    fixed_head: V3 UVM (ventral)
    fixed_tail: V2 UVM (ventral)
    figure_grid:
      - ["angle", "eccen"]
      - ["curvature", "vexpl"]
  V3 Dorsal Periphery:
    fixed_head: V3 LVM (dorsal)
    fixed_tail: V2 LVM (dorsal)
    figure_grid:
      - ["angle", "eccen"]
      - ["curvature", "vexpl"]
  # hV4 contour:
  hV4 Outer:
    type: contour
    fixed_head: V3 Foveal Point
    figure_grid:
      - ["angle", "eccen"]
      - ["curvature", "vexpl"]
  # VO contour:
  VO Outer:
    type: contour
    fixed_head: V3 UVM (ventral)
    figure_grid:
      - ["angle", "eccen"]
      - ["curvature", "vexpl"]
  # hV4|VO boundary:
  hV4|VO Boundary:
    type: contour
    figure_grid:
      - ["angle", "eccen"]
      - ["curvature", "vexpl"]
  # VO1|2 boundary:
  VO1|2 Boundary: 
    type: contour
    figure_grid:
      - ["angle", "eccen"]
      - ["curvature", "vexpl"]
  # V3a|b contours:
  V3a|b Outer:
    type: contour
    fixed_head: V3 LVM (dorsal)
    figure_grid:
      - ["angle", "eccen"]
      - ["curvature", "vexpl"]
  V3a|b Inner Boundary:
    type: contour
    figure_grid:
      - ["angle", "eccen"]
      - ["curvature", "vexpl"]
  # IPS0 Outer:
  IPS0 Outer:
    type: contour
    figure_grid:
      - ["angle", "eccen"]
      - ["curvature", "vexpl"]
  # LO1 Outer:
  LO1 Outer:
    type: contour
    fixed_head: V3 Foveal Point
    figure_grid:
      - ["angle", "eccen"]
      - ["curvature", "vexpl"]
  # Isoecentricity contours:
  0.5 Degrees Eccentricity:
    type: contour
    figure_grid:
      - ["eccen_0.5", "angle"]
      - ["eccen", "vexpl"]
  1.0 Degrees Eccentricity:
    type: contour
    figure_grid:
      - ["eccen_1.0", "angle"]
      - ["eccen", "vexpl"]
  2.0 Degrees Eccentricity:
    type: contour
    figure_grid:
      - ["eccen_2.0", "angle"]
      - ["eccen", "vexpl"]
  4.0 Degrees Eccentricity:
    type: contour
    figure_grid:
      - ["eccen_4.0", "angle"]
      - ["eccen", "vexpl"]
  7.0 Degrees Eccentricity:
    type: contour
    figure_grid:
      - ["eccen_7.0", "angle"]
      - ["eccen", "vexpl"]
    filter: |
      return target["Dataset"] != "NSD"
  11.0 Degrees Eccentricity:
    type: contour
    figure_grid:
      - ["eccen_11.0", "angle"]
      - ["eccen", "vexpl"]
    filter: |
      return target["Dataset"] in ( "NYU-Retinotopy", )


figures:
  angle: |
    # prepare (formatted) target information for figure code below
    hemisphere = target["Hemisphere"]  # string
    fs_hemi    = f"{hemisphere[0].lower()}h"

    # prepare colormap name and values for figure
    colormap_name   = f"polar_angle_{fs_hemi}"
    colormap_values = target["flatmap"].properties["angle"]

    ny.cortex_plot(
      mesh  = target["flatmap"], 
      color = { colormap_name: colormap_values }, 
      axes  = axes
    )
  eccen: |
    ny.cortex_plot(
      mesh  = target["flatmap"], 
      color = { "eccentricity": target["flatmap"].properties["eccen"] }, 
      axes = axes
    )
  vexpl: |
    ny.cortex_plot(
      mesh  = target["flatmap"], 
      color = "vexpl", 
      cmap  = "hot", 
      vmin  = 0, 
      vmax  = 100, 
      axes = axes
    )
  curvature: |
    ny.cortex_plot(mesh = target["flatmap"], axes = axes)
  _: |
    # Prepare property name and threshold from figure name
    prop_name, threshold = key.split("_")
    
    # Compute values relative to threshold 
    # (clipped to [0, 16] eccentricity to remove extreme outliers)
    values = np.clip(target["flatmap"].properties[prop_name].copy(), 0, 16)
    values = values - float(threshold) 
  
    # Normalize negative values to [-1, 0]
    negative_index = values < 0
    values[negative_index] = (values[negative_index] /
      np.abs(np.nanmin(values[negative_index])))

    # Normalize positive values to [0, 1]
    positive_index = values > 0
    values[positive_index] = (values[positive_index] / 
      np.nanmax(values[positive_index]))

    # Plot with diverging colormap, centered at the threshold value
    ny.cortex_plot(
      mesh  = target["flatmap"], 
      color = values, 
      cmap  = edge_cmap, 
      vmin  = -1, 
      vmax  = 1, 
      axes  = axes
    )
  term: |
    # figure aesthetics and limits
    xy = target["flatmap"].coordinates
    (xmin, ymin) = np.min(xy, axis = 1)
    (xmax, ymax) = np.max(xy, axis = 1)
    axes.set_xlim((xmin, xmax))
    axes.set_ylim((ymin, ymax))